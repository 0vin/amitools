#!/usr/bin/env python2.7
#
# hunktool
#
# the swiss-army knife for Amiga Hunk executable file format
#
# written by Christian Vogelgsang (chris@vogelgsang.org)

import sys
import argparse
import pprint

from amitools.FileScanner import FileScanner
from amitools import Hunk
from amitools import ELF

def print_pretty(data):
  pp = pprint.PrettyPrinter(indent=2)
  pp.pprint(data)

# ----- commands -------------------------------------------------------------

# ----- Validator -----

class Validator:
  def __init__(self, args):
    self.counts = {}
    self.args = args
    self.failed_files = []

  def handle_file(self, path, hunk_file, error_code):
    if not self.counts.has_key(error_code):
      self.counts[error_code] = 0
    self.counts[error_code] += 1
    print path,

    # abort if hunk parser failed!
    if error_code != Hunk.RESULT_OK:
      print Hunk.result_names[error_code], hunk_file.error_string
      if args.dump:
        print_pretty(hunk_file.hunk_blks)
      self.failed_files.append( (path, "READ: " + hunk_file.error_string) )        
      return not self.args.stop

    # if verbose then print block structure
    if args.verbose:
      print
      print "  blocks:",hunk_file.get_hunk_blk_summary()
      if args.dump:
        print_pretty(hunk_file.hunk_blks)        
      print "  type:  ",
    
    # build hunk structure
    ok = hunk_file.build_hunks()
    if not ok:
      print "BUILD HUNK FAILED: %s" % (hunk_file.error_string)
      self.failed_files.append( (path, "BUILD: " + hunk_file.error_string) )
      return not self.args.stop
    
    # print recognized file type name
    print Hunk.type_names[hunk_file.type],
    
    # if verbose then print hunk structure
    if args.verbose:
      print 
      print "  hunks: ",hunk_file.get_hunk_summary()
      if args.dump:
        print_pretty(hunk_file.hunks)
    else:
      print
    
    return True
  
  def result(self):
    for code in self.counts.keys():
      print Hunk.result_names[code],":",self.counts[code]
    for failed in self.failed_files:
      print failed[0],failed[1]
    return 0
      
  def process_file(self, path, fobj, cmd):
    hunk_file = Hunk.HunkFile()
    result = hunk_file.read_file_obj(path,fobj,None)
    # ignore non hunk files
    if result == Hunk.RESULT_NO_HUNK_FILE:
      return True
    return self.handle_file(path, hunk_file, result)
  
  def run(self):
    scanner = FileScanner(lambda path, fobj: self.process_file(path, fobj, cmd), use_adf=args.adf, use_lha=args.lha, stop_on_error=args.stop)
    for path in args.files:
      ok = scanner.handle_path(path)
      if not ok:
        print "ABORTED"
    return cmd.result()

# ----- Elf2Hunk -----

class Elf2Hunk:
  def __init__(self,args):
    self.args = args
  
  def run(self):
    for f in args.files:
      elf = ELF.ELF()
      if not elf.load(f):
        print "ERROR loading ELF:",elf.error_string
        return 1
      elf.dump_segment_headers()
      elf.dump_symbols()
    return 0
  
# ----- main -----
parser = argparse.ArgumentParser()
parser.add_argument('command', help="command: validate, elf2hunk")
parser.add_argument('files', nargs='+')
parser.add_argument('-d', '--dump', action='store_true', default=False, help="dump the hunk structure")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be more verbos")
parser.add_argument('-a', '--adf', nargs='?', default='unadf', help="enable adf scanner (requires unadf tool)")
parser.add_argument('-l', '--lha', nargs='?', default='lha', help="enable lha scanner (with given lha executable)")
parser.add_argument('-s', '--stop', action='store_true', default=False, help="stop on error")
args = parser.parse_args()

# call scanner and process all files with selected command
cmd_map = {
"validate" : Validator,
"elf2hunk" : Elf2Hunk
}
cmd = args.command
if not cmd_map.has_key(cmd):
  print "INVALID COMMAND:",cmd
  sys.exit(1)
cmd_cls = cmd_map[cmd]

# execute command
cmd = cmd_cls(args)
res = cmd.run()
sys.exit(res)
