#!/usr/bin/env python2.7
#
# hunktool
#
# the swiss-army knife for Amiga Hunk executable file format
#
# written by Christian Vogelgsang (chris@vogelgsang.org)

import sys
import argparse
import pprint

from amitools.FileScanner import FileScanner
from amitools import Hunk

def print_pretty(data):
  pp = pprint.PrettyPrinter(indent=2)
  pp.pprint(data)

# ----- commands -----

class Validator:
  def __init__(self, args):
    self.counts = {}
    self.args = args
    self.failed_files = []

  def handle_file(self, path, hunk_file, error_code):
    if not self.counts.has_key(error_code):
      self.counts[error_code] = 0
    self.counts[error_code] += 1
    print path,

    # abort if hunk parser failed!
    if error_code != Hunk.RESULT_OK:
      print Hunk.result_names[error_code], hunk_file.error_string
      if args.dump:
        print_pretty(hunk_file.hunk_blks)
      self.failed_files.append( (path, "READ: " + hunk_file.error_string) )        
      return not self.args.stop

    # if verbose then print block structure
    if args.verbose:
      print
      print "  blocks:",hunk_file.get_hunk_blk_summary()
      if args.dump:
        print_pretty(hunk_file.hunk_blks)        
      print "  type:  ",
    
    # build hunk structure
    ok = hunk_file.build_hunks()
    if not ok:
      print "BUILD HUNK FAILED: %s" % (hunk_file.error_string)
      self.failed_files.append( (path, "BUILD: " + hunk_file.error_string) )
      return not self.args.stop
    
    # print recognized file type name
    print Hunk.type_names[hunk_file.type],
    
    # if verbose then print hunk structure
    if args.verbose:
      print 
      print "  hunks: ",hunk_file.get_hunk_summary()
      if args.dump:
        print_pretty(hunk_file.hunks)
    else:
      print
    
    return True
  
  def result(self):
    for code in self.counts.keys():
      print Hunk.result_names[code],":",self.counts[code]
    for failed in self.failed_files:
      print failed[0],failed[1]
    return 0

# generic hunk reader
def handle_file(path, fobj, cmd):
  hunk_file = Hunk.HunkFile()
  result = hunk_file.read_file_obj(path,fobj,None)
  # ignore non hunk files
  if result == Hunk.RESULT_NO_HUNK_FILE:
    return True
  return cmd.handle_file(path, hunk_file, result)

# ----- main -----
parser = argparse.ArgumentParser()
#parser.add_argument('command')
parser.add_argument('hunkfiles', nargs='+')
parser.add_argument('-d', '--dump', action='store_true', default=False, help="dump the hunk structure")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be more verbos")
parser.add_argument('-a', '--adf', action='store_true', default=False, help="enable adf scanner (requires adflib shared lib)")
parser.add_argument('-l', '--lha', nargs='?', default='lha', help="enable lha scanner (with given lha executable)")
parser.add_argument('-s', '--stop', action='store_true', default=False, help="stop on error")
args = parser.parse_args()

# call scanner and process all files with selected command
cmd = Validator(args)
scanner = FileScanner(lambda path, fobj: handle_file(path, fobj, cmd), use_adf=args.adf, use_lha=args.lha)
for path in args.hunkfiles:
  ok = scanner.handle_path(path)
  if not ok:
    print "ABORTED"
res = cmd.result()
sys.exit(res)
