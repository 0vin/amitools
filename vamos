#!/usr/bin/env python2.7
#
# vamos [optoins] <amiga binary> [args ...]
#
# run an m68k AmigaOS binary
#
# written by Christian Vogelgsang (chris@vogelgsang.org)

import sys
import argparse
import os

from musashi import m68k
from musashi import emu

from amitools.vamos.Log import *
from amitools.vamos.Vamos import Vamos
from amitools.vamos.Exceptions import *
from amitools.vamos.AccessMemory import AccessMemory
from amitools.vamos.VamosConfig import VamosConfig
from amitools.vamos.path.PathManager import PathManager
from amitools.vamos.VamosRun import VamosRun
from amitools.vamos.Process import Process
from amitools.vamos.HardwareAccess import HardwareAccess

# ----- main -----------------------------------------------------------------
# retrieve vamos home and data dir
home_dir = os.path.dirname(os.path.realpath(sys.argv[0]))
data_dir = os.path.join(home_dir, "data")

# --- args --
parser = argparse.ArgumentParser()
parser.add_argument('bin', help="AmigaOS binary to run")
parser.add_argument('args', nargs='*', help="AmigaOS binary arguments")
# config options
parser.add_argument('-c', '--config-file', action='store', default=None, help="vamos config file")
parser.add_argument('-S', '--skip-default-configs', action='store_true', default=False, help="do not read ~/.vamosrc or ./vamosrc")
# logging config
parser.add_argument('-l', '--logging', action='store', default=None, help="logging settings: <chan>:<level>,*:<level>,...")
parser.add_argument('-v', '--verbose', action='store_true', default=None, help="be more verbos")
parser.add_argument('-q', '--quiet', action='store_true', default=None, help="do not output any logging")
parser.add_argument('-b', '--benchmark', action='store_true', default=None, help="enable benchmarking")
parser.add_argument('-L', '--log-file', action='store', default=None, help="write all log messages to a file")
# low-level tracing
parser.add_argument('-I', '--instr-trace', action='store_true', default=None, help="enable instruction trace")
parser.add_argument('-t', '--memory-trace', action='store_true', default=None, help="enable memory tracing (slower)")
parser.add_argument('-T', '--internal-memory-trace', action='store_true', default=None, help="enable internal memory tracing (slow)")
parser.add_argument('-r', '--reg-dump', action='store_true', default=None, help="add register dump to instruction trace")
# cpu emu
parser.add_argument('-C', '--cpu', action='store', default=None, help="Set type of CPU to emulate (68000 or 68020)")
parser.add_argument('-y', '--max-cycles', action='store', type=int, default=None, help="maximum number of cycles to execute")
parser.add_argument('-B', '--cycles-per-block', action='store', type=int, default=None, help="cycles per block")
# system
parser.add_argument('-m', '--ram-size', action='store', default=None, type=int, help="set RAM size in KiB")
parser.add_argument('-s', '--stack-size', action='store', default=None, help="set stack size in KiB")
parser.add_argument('-H', '--hw-access', action='store', default=None, help="What to do on direct HW access? (emu,ignore,abort)")
# dirs
parser.add_argument('-D', '--data-dir', action='store', default=None, help="set vamos data directory (default: %s)" % data_dir)
# lib config
parser.add_argument('-O', '--lib-options', action='append', default=None, help="set lib options: <lib>:<key>=<value>,...")
# path config
parser.add_argument('-a', '--assign', action='append', default=None, help="add AmigaOS assign: name:[+]/sys/path[,/more/path]")
parser.add_argument('-V', '--volume', action='append', default=None, help="define AmigaOS volume: name:/abs/sys/path")
parser.add_argument('-A', '--auto-assign', action='store', default=None, help="define auto assign ami path, e.g. vol:/ami/path")
parser.add_argument('-p', '--path', action='append', default=None, help="define command search ami path, e.g. c:")
args = parser.parse_args()

# --- init config ---
cfg = VamosConfig(extra_file=args.config_file, skip_defaults=args.skip_default_configs, args=args, def_data_dir=data_dir)

# --- init logging ---
if not log_setup(cfg.logging, cfg.verbose, cfg.quiet, cfg.log_file):
  log_help()
  sys.exit(1)
cfg.log()

# ----- vamos! ---------------------------------------------------------------
# setup CPU
if cfg.cpu in ('68000', '000', '00'):
  cpu_type = m68k.M68K_CPU_TYPE_68000
elif cfg.cpu in ('68020', '020', '20'):
  cpu_type = m68k.M68K_CPU_TYPE_68020
else:
  log_main.error("Invalid CPU type: %s" % cfg.cpu)
  sys.exit(1)
log_main.info("setting up CPU: %s = %d" % (cfg.cpu, cpu_type))
cpu = emu.CPU(cpu_type)

# setup memory
max_mem = 0xbf0000 / 1024
if cfg.ram_size >= max_mem:
  log_main.error("too much RAM requested. max allowed KiB: %d", max_mem)
  sys.exit(1)
mem = emu.Memory(cfg.ram_size)
log_main.info("setting up main memory with %s KiB RAM: top=%06x" % (cfg.ram_size, cfg.ram_size * 1024))

# setup traps
traps = emu.Traps()

# combine to vamos instance
vamos = Vamos(mem, cpu, traps, cfg)

# direct hw access
if cfg.hw_access == "emu":
  vamos.hw_access.set_mode(HardwareAccess.MODE_EMU)
elif cfg.hw_access == "ignore":
  vamos.hw_access.set_mode(HardwareAccess.MODE_IGNORE)
elif cfg.hw_access == "abort":
  vamos.hw_access.set_mode(HardwareAccess.MODE_ABORT)
else:
  log_main.error("Invalid HW Access mode: %s",cfg.hw_access)
  sys.exit(1)
log_main.info("setting up HW Access mode: %s",cfg.hw_access)

# enable mem trace?
if cfg.memory_trace:
  mem.set_trace_mode(1)
  mem.set_trace_func(vamos.label_mgr.trace_mem)
  if not log_mem.isEnabledFor(logging.DEBUG):
    log_mem.setLevel(logging.DEBUG)
# enable internal memory trace?
if cfg.internal_memory_trace:
  AccessMemory.label_mgr = vamos.label_mgr
  if not log_mem_int.isEnabledFor(logging.INFO):
    log_mem_int.setLevel(logging.INFO)

# set invalid access handler for memory
mem.set_invalid_func(vamos.error_tracker.report_invalid_memory)

# --- setup vamos ---
if not vamos.init(cfg):
  sys.exit(1)

# --- create main process ---
proc = Process(vamos, args.bin, args.args, stack_size=cfg.stack_size*1024)
if not proc.ok:
  sys.exit(1)
vamos.set_main_process(proc)

# ------ main loop ------

# init cpu and initial registers
run = VamosRun(vamos, args.benchmark)
run.init_cpu()

# set reset opcode/trap handler
cpu.set_reset_instr_callback(run.reset_func)

# enable instruction trace?
def instr_hook():
  # add register dump
  if cfg.reg_dump:
    res = cpu.dump_state()
    for r in res:
      log_instr.info(r)
  # disassemble line
  pc = cpu.r_reg(m68k.M68K_REG_PC)
  label, sym, src = vamos.label_mgr.get_disasm_info(pc)
  _,txt = cpu.disassemble(pc)
  if sym is not None:
    log_instr.info("%s%s:", " "*40, sym)
  if src is not None:
    log_instr.info("%s%s", " "*50, src)
  log_instr.info("%-40s  %06x    %-20s" % (label, pc, txt))

if cfg.instr_trace:
  if not log_instr.isEnabledFor(logging.INFO):
    log_instr.setLevel(logging.INFO)
  cpu.set_instr_hook_callback(instr_hook)

# main loop
exit_code = run.run(cfg.cycles_per_block, cfg.max_cycles)

# free process
proc.free()

# shutdown vamos
vamos.cleanup()

# exit
log_main.info("vamos is exiting")
sys.exit(exit_code)
