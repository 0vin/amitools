#!/usr/bin/env python2.7
#
# vamos [optoins] <amiga binary> [args ...]
#
# run an m68k AmigaOS binary
#
# written by Christian Vogelgsang (chris@vogelgsang.org)

import sys
import argparse
import os
import os.path
import traceback
import time

from musashi import m68k

from amitools.vamos.CPU import CPU
from amitools.vamos.Log import *
from amitools.vamos.Vamos import Vamos
from amitools.vamos.Exceptions import *

# ----- classes -----

class MusashiCPU(CPU):
  def __init__(self):
    CPU.__init__(self,"musashi")
  def w_reg(self,reg, val):
    m68k.set_reg(reg,val)
  def r_reg(self,reg):
    return m68k.get_reg(reg)
  def w_pc(self, val):
    m68k.set_reg(m68k.M68K_REG_PC,val)
  def r_pc(self):
    return m68k.get_reg(m68k.M68K_REG_PC)
  def w_sr(self, val):
    m68k.set_reg(m68k.M68K_REG_SR,val)
  def r_sr(sefl):
    return m68k.get_reg(m68k.M68K_REG_SR)

# ----- main -----

# --- preset args ---
vamos_prefix = os.path.join(os.environ['HOME'],".vamos")
lib_versions = {
  'dos' : 39,
  'exec' : 39
}

# --- args ---
parser = argparse.ArgumentParser()
parser.add_argument('bin', help="AmigaOS binary to run")
parser.add_argument('args', nargs='*', help="AmigaOS binary arguments")
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be more verbos")
parser.add_argument('-c', '--cycles', action='store', type=int, default=0, help="maximum number of cycles to execute")
parser.add_argument('-b', '--block', action='store', type=int, default=1000, help="cycles per block")
parser.add_argument('-l', '--logging', action='store', default=None, help="logging settings: <chan>:<level>,*:<level>,...")
parser.add_argument('-P', '--prefix', action='store', default=vamos_prefix, help="vamos directory prefix (%s)" % vamos_prefix)
parser.add_argument('-V', '--lib-version', action='store', default=None, help="set lib version: <lib>:<version>,...")
parser.add_argument('-m', '--ram-size', action='store', default=1024, help="set RAM size in KiB")
parser.add_argument('-s', '--stack-size', action='store', default=4, help="set stack size in KiB")
parser.add_argument('-t', '--memory-trace', action='store_true', default=False, help="enable memory tracing (slow)")
args = parser.parse_args()
vamos_prefix = args.prefix

# --- parse args ---
if args.lib_version != None:
  for p in args.lib_version.split(','):
    n,v = p.split(':')
    lib_versions[n] = int(v)

# --- init logging ---
log_setup(args.logging)

# ----- vamos! ---------------------------------------------------------------
cpu = MusashiCPU()
vamos = Vamos(args.ram_size, cpu)

# --- setup stack ---
vamos.init_stack(args.stack_size)

# --- load segments of binary ---
if not vamos.load_main_binary(args.bin):
  log_main.error("failed loading binary: '%s' %s", args.bin, vamos.seg_loader.error)
  sys.exit(1)
# place args in memory
vamos.init_args(args.args)

# --- libs ---
vamos.init_managers(args.prefix)
vamos.register_base_libs(lib_versions['exec'], lib_versions['dos'])

# --- vamos context ---
ctx = vamos.init_context()

# --- in memory process struct ---
vamos.setup_process()
vamos.open_exec_lib()
vamos.create_old_dos_guard()

# ----- start cpu ------------------------------------------------------------
# prepare m68k
log_main.info("setting up m68k")
m68k.set_read_memory(*ctx.mem.get_read_funcs(args.memory_trace))
m68k.set_write_memory(*ctx.mem.get_write_funcs(args.memory_trace))
m68k.set_cpu_type(m68k.M68K_CPU_TYPE_68000)

# reset CPU with a temporary reset range
log_main.info("resetting cpu...")
# setup stack & first PC
ctx.mem.w32(0, vamos.stack_initial)
ctx.mem.w32(4, vamos.prog_start)
m68k.pulse_reset()

# set end RESET opcode at 0 and execbase at 4
op_reset = 0x04e70
ctx.mem.w16(0, op_reset)
ctx.mem.w32(4, vamos.exec_lib.lib_base)

# setup RESET: catch end of program and all library traps
stay = True
et = vamos.error_tracker
trap_time = 0.0
def reset_func():
  global et
  pc = m68k.get_reg(m68k.M68K_REG_PC) - 2
  # addr == 0 ? -> end reached
  if pc == 0:
    global stay
    m68k.end_timeslice()
    stay = False
  # a lib trap!
  elif not et.has_errors:
    global ctx, trap_time
    try:
      begin = time.time()
      vamos.lib_mgr.call_internal_lib(pc, ctx)
      end = time.time()
      trap_time += end - begin
    except BaseException as e:
      et.report_error(e)
      
m68k.set_reset_instr_callback(reset_func)

# setup arg in D0/A0
m68k.set_reg(m68k.M68K_REG_D0, vamos.arg_len)
m68k.set_reg(m68k.M68K_REG_A0, vamos.arg_base)

# to track old dos values
m68k.set_reg(m68k.M68K_REG_A2, vamos.dos_guard_base)
m68k.set_reg(m68k.M68K_REG_A5, vamos.dos_guard_base)
m68k.set_reg(m68k.M68K_REG_A6, vamos.dos_guard_base)

# ----- start main CPU loop --------------------------------------------------
log_main.info("start cpu: %06x", vamos.prog_start)
total_cycles = 0
cycles_per_run = args.block
max_cycles = args.cycles
start_time = time.time()

# main loop
while stay:
  total_cycles += m68k.execute(cycles_per_run)
  # end after enough cycles
  if max_cycles > 0 and total_cycles >= max_cycles:
    break
  # some error fored a quit?
  if et.has_errors:
    break
  
end_time = time.time()
delta_time = end_time - start_time
delta_time -= trap_time
mhz = total_cycles / (1000000.0 * delta_time)
log_main.info("done (%d cycles in %.4gs -> %.2g MHz, trap time %.4gs)", total_cycles, delta_time, mhz, trap_time)

# if errors happened then report them now
if et.has_errors:
  log_main.error("After %d cycles:", total_cycles)
  et.dump()
      
