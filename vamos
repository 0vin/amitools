#!/usr/bin/env python2.7
#
# vamos [optoins] <amiga binary> [args ...]
#
# run an m68k AmigaOS binary
#
# written by Christian Vogelgsang (chris@vogelgsang.org)

import sys
import argparse
import pprint
import struct

from amitools.FileScanner import FileScanner
from amitools import Hunk
from amitools import HunkReader
from amitools import HunkRelocate
from amitools import HunkShow

from musashi import m68k

from amitools.vamos import MemoryBlock
from amitools.vamos import MemoryLayout
from amitools.vamos import ResetRange
from amitools.vamos import EndRange
from amitools.vamos import AmigaLibrary
from amitools.vamos import AmigaExecBase
from amitools.vamos import MachineContext
from amitools.vamos import CPU
from amitools.vamos import LibManager

from amitools.vamos.lib import ExecLibrary
from amitools.vamos.lib import DosLibrary

import ctypes

# ----- classes -----

class MusashiCPU(CPU.CPU):
  def __init__(self):
    CPU.__init__("musashi")
  def w_reg(self,reg, val):
    m68k.set_reg(reg,val)
  def r_reg(self,reg):
    return m68k.get_reg(reg)

# ----- main -----

# --- args ---
parser = argparse.ArgumentParser()
parser.add_argument('bin', help="command: AmigaOS binary")
parser.add_argument('args', nargs='*')
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be more verbos")
args = parser.parse_args()

bin = args.bin
args = args.args
print "vamos: %s %s" % (bin, args)

# --- load binary ---
hunk_file = HunkReader.HunkReader()
fobj = file(bin,"rb")
result = hunk_file.read_file_obj(bin,fobj,None)
if result != Hunk.RESULT_OK:
  print "Error loading '%s'" % (bin)
  sys.exit(1)
# build segments
ok = hunk_file.build_segments()
if not ok:
  print "Error building segments for '%s'" % (bin)
  sys.exit(2)
# make sure its a loadseg()
if hunk_file.type != Hunk.TYPE_LOADSEG:
  print "File not loadSeg()able: '%s'" % (bin)
  sys.exit(3)

# --- create memory layout ---
print "setting up memory layout"
layout = MemoryLayout.MemoryLayout(verbose=True)
context = MachineContext.MachineContext(MusashiCPU(),layout)

# place prog segments
print "segments in '%s'" % bin
prog_base = 0x010000
off = prog_base
relocator = HunkRelocate.HunkRelocate(hunk_file)
prog_data = relocator.relocate_one_block(prog_base)
prog_size = len(prog_data)
prog_mem = MemoryBlock.MemoryBlock("prog", prog_base, prog_size)
prog_mem.write_data(prog_base, prog_data)
layout.add_range(prog_mem)
print prog_mem

# setup stack
magic_end = 0xff0000
stack_base = 0x080000
stack_size = 0x001000
stack_end = stack_base + stack_size
stack_mem = MemoryBlock.MemoryBlock("stack", stack_base, stack_size)
stack_initial = stack_end - 4
stack_mem.w32(stack_initial, magic_end)
layout.add_range(stack_mem)

# setup argument
arg_base = 0x1000
arg_text = " ".join(args)
arg_len  = len(arg_text)
arg_size = arg_len + 1
arg_mem  = MemoryBlock.MemoryBlock("args", arg_base, arg_size)
arg_mem.write_data(arg_base, arg_text)
arg_mem.write_mem(0, arg_base + arg_len, 0)
layout.add_range(arg_mem)
print "args: %s (%d)" % (arg_text, arg_len)

# --- libs ---
lib_base = 0xf08000
lib_off  = 0x010000
lib_mgr  = LibManager.LibManager(lib_base, lib_off, layout)

# setup exec.library
exec_lib = ExecLibrary.ExecLibrary(0, context, lib_mgr)
lib_mgr.add_lib(exec_lib)
exec_base = lib_mgr.open_lib("exec.library",0)
exec_base_range = AmigaExecBase.AmigaExecBase(exec_base)

# setup dos.library
dos_lib = DosLibrary.DosLibrary(36, context)
lib_mgr.add_lib(dos_lib)

# --- start cpu ---
# prepare m68k
print "setting up m68k"
m68k.set_read_memory(*layout.get_read_funcs())
m68k.set_write_memory(*layout.get_write_funcs())
m68k.set_cpu_type(m68k.M68K_CPU_TYPE_68000)

print "resetting cpu..."
reset_range = ResetRange.ResetRange(prog_base, stack_initial)
layout.add_range(reset_range)
m68k.pulse_reset()
layout.remove_range(reset_range)

layout.add_range(exec_base_range)

# setup RESET = end handler
end_range = EndRange.EndRange(magic_end)
layout.add_range(end_range)
stay = True
def end_func():
  global stay
  m68k.end_timeslice()
  stay = False
m68k.set_reset_instr_callback(end_func)

# setup arg in D0/A0
m68k.set_reg(m68k.M68K_REG_D0, arg_len)
m68k.set_reg(m68k.M68K_REG_A0, arg_base)

print "go!"
total_cycles = 0
cycles_per_run = 100
while stay:
  total_cycles += m68k.execute(cycles_per_run)
print "done (%d cycles)" % (total_cycles)
