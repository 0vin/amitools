#!/usr/bin/env python2.7
#
# vamos [optoins] <amiga binary> [args ...]
#
# run an m68k AmigaOS binary
#
# written by Christian Vogelgsang (chris@vogelgsang.org)

import sys
import argparse
import pprint
import struct

from amitools.FileScanner import FileScanner
from amitools import Hunk
from amitools import HunkReader
from amitools import HunkRelocate
from amitools import HunkShow

from musashi import m68k

from amitools.vamos import MemoryBlock
from amitools.vamos import MemoryLayout
from amitools.vamos import MemoryAlloc
from amitools.vamos import ResetRange
from amitools.vamos import EndRange
from amitools.vamos import AmigaLibrary
from amitools.vamos import AmigaExecBase
from amitools.vamos import MachineContext
from amitools.vamos import CPU
from amitools.vamos import LibManager

# lib
from amitools.vamos.lib import ExecLibrary
from amitools.vamos.lib import DosLibrary

import ctypes

# ----- classes -----

class MusashiCPU(CPU.CPU):
  def __init__(self):
    CPU.__init__("musashi")
  def w_reg(self,reg, val):
    m68k.set_reg(reg,val)
  def r_reg(self,reg):
    return m68k.get_reg(reg)

# ----- main -----

# --- args ---
parser = argparse.ArgumentParser()
parser.add_argument('bin', help="command: AmigaOS binary")
parser.add_argument('args', nargs='*')
parser.add_argument('-v', '--verbose', action='store_true', default=False, help="be more verbos")
parser.add_argument('-c', '--cycles', action='store', type=int, default=0, help="maximum number of cycles to execute")
parser.add_argument('-b', '--block', action='store', type=int, default=1000, help="cycles per block")
parser.add_argument('-m', '--memory_trace', action='store_true', default=False, help="trace memory")
args = parser.parse_args()

bin = args.bin
bin_args = args.args
print "vamos: %s %s" % (bin, bin_args)

# --- load binary ---
hunk_file = HunkReader.HunkReader()
fobj = file(bin,"rb")
result = hunk_file.read_file_obj(bin,fobj,None)
if result != Hunk.RESULT_OK:
  print "Error loading '%s'" % (bin)
  sys.exit(1)
# build segments
ok = hunk_file.build_segments()
if not ok:
  print "Error building segments for '%s'" % (bin)
  sys.exit(2)
# make sure its a loadseg()
if hunk_file.type != Hunk.TYPE_LOADSEG:
  print "File not loadSeg()able: '%s'" % (bin)
  sys.exit(3)

# --- create memory layout ---
print "setting up memory layout"
layout = MemoryLayout.MemoryLayout("main_memory",0,0x1000000,verbose=args.memory_trace)
context = MachineContext.MachineContext(MusashiCPU(),layout)

# place prog segments
prog_base = 0x010000
prog_start = prog_base
off = prog_base
relocator = HunkRelocate.HunkRelocate(hunk_file)
prog_data = relocator.relocate_one_block(prog_base, padding=8)
prog_size = len(prog_data)
prog_mem = MemoryBlock.MemoryBlock("prog", prog_base, prog_size)
prog_mem.write_data(prog_base, prog_data)
layout.add_range(prog_mem)
print prog_mem

# some segment info
seg_sizes = relocator.get_sizes()
seg_addrs = relocator.get_seq_addrs(prog_base, padding=8)
for i in xrange(len(seg_sizes)):
  print "  seg:  @%06x  +%06x" % (seg_addrs[i], seg_sizes[i])

# setup stack
magic_end = 0xff0000
stack_base = 0x080000
stack_size = 0x001000
stack_end = stack_base + stack_size
stack_mem = MemoryBlock.MemoryBlock("stack", stack_base, stack_size)
# prepare stack
# TOP: size
# TOP-4: return from program -> magic_ed
stack_initial = stack_end - 4
stack_mem.w32(stack_initial, stack_size)
stack_initial -= 4
stack_mem.w32(stack_initial, magic_end)
layout.add_range(stack_mem)

# setup heap
heap_base = 0x100000
heap_size = 0x080000
heap_mem = MemoryAlloc.MemoryAlloc("heap", heap_base, heap_size, verbose=args.memory_trace)
layout.add_range(heap_mem)

# setup argument
arg_base = 0x1000
arg_text = " ".join(bin_args)
arg_len  = len(arg_text)
arg_size = arg_len + 1
arg_mem  = MemoryBlock.MemoryBlock("args", arg_base, arg_size)
arg_mem.write_data(arg_base, arg_text)
arg_mem.write_mem(0, arg_base + arg_len, 0)
layout.add_range(arg_mem)
print "args: %s (%d)" % (arg_text, arg_len)
print arg_mem

# --- libs ---
lib_base = 0xf08000
lib_off  = 0x010000
lib_mgr  = LibManager.LibManager(lib_base, lib_off, layout)

# setup exec.library
exec_lib = ExecLibrary.ExecLibrary(0, context, lib_mgr, heap_mem)
lib_mgr.add_lib(exec_lib)
exec_base = lib_mgr.open_lib("exec.library",0)
exec_base_range = AmigaExecBase.AmigaExecBase(exec_base)

# setup dos.library
dos_lib = DosLibrary.DosLibrary(36, context)
lib_mgr.add_lib(dos_lib)

# --- start cpu ---
# prepare m68k
print "setting up m68k"
m68k.set_read_memory(*layout.get_read_funcs())
m68k.set_write_memory(*layout.get_write_funcs())
m68k.set_cpu_type(m68k.M68K_CPU_TYPE_68000)

print "resetting cpu..."
reset_range = ResetRange.ResetRange(prog_start, stack_initial)
layout.add_range(reset_range)
m68k.pulse_reset()
layout.remove_range(reset_range)

layout.add_range(exec_base_range)

# setup RESET = end handler
end_range = EndRange.EndRange(magic_end)
layout.add_range(end_range)
stay = True
def end_func():
  global stay
  m68k.end_timeslice()
  stay = False
m68k.set_reset_instr_callback(end_func)

# setup arg in D0/A0
m68k.set_reg(m68k.M68K_REG_D0, arg_len)
m68k.set_reg(m68k.M68K_REG_A0, arg_base)

print "go!"
total_cycles = 0
cycles_per_run = args.block
max_cycles = args.cycles 
while stay:
  total_cycles += m68k.execute(cycles_per_run)
  # end after enough cycles
  if max_cycles > 0 and total_cycles >= max_cycles:
    break
  # if invalid reads or writes then abort
  if len(layout.invalid_reads)>0:
    print "ERROR: invalid reads:"
    for e in layout.invalid_reads:
      print "R(%d): %06x" % e
    stay = False
  if len(layout.invalid_writes)>0:
    print "ERROR: invalid writes:"
    for e in layout.invalid_writes:
      print "R(%d): %06x" % e
    stay = False
    
print "done (%d cycles)" % (total_cycles)
